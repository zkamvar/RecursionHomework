(restab[[2]] - 1)*2
diff(call_diff)
restab[[2]]
restab[[3]]
fib(3)
fib(2)
fib(3)
fib(2)-1
fib(3)-1
fib(3)*2-1
fib(4)*2-1
fib(5)*2-1
fib(4)
fib(4)*2 - 1
fib(5)*2 - 1
fib(5)
fib(6)
restab[[2]]*2 - restab[[3]]
diff(restab[[3]])
diff(restab[[3]])/2
restab[[2]]
restab[[3]]
fib(21)
4181*2 + 1 + 6765 + 1
CALL_COUNTER <- 0
fib(21)
4181*2 + 1 + 6765*2 + 1
4181*2 - 1 + 6765*2 - 1
(4181*2) + 1 + (6765*2) + 1
(4181*2) + (6765*2) - 1
restab[[2]][19] + restab[[2]][20]
(nextcall <- nextfib*2 - 1)
(nextfib <- restab[[2]][19] + restab[[2]][20])
(nextcall <- nextfib*2 - 1)
(nextfib <- restab[[2]][19] + restab[[2]][20])
(nextcall <- nextfib*2 - 1)
CALL_COUNTER <- 0
fib(21)
CALL_COUNTER
(4181*2) + (6765*2) - 1
library(rstackdeque)
s <- rstack()
s <- insert_top(s, "A")
s
s <- insert_top(s, "B")
s <- insert_top(s, "C")
s
print(s)
print(peek_top(s))
s <- without_top(s)
print(s)
g <- insert_top(s, "X")
print(s)
print(g)
insert_top
glist <- as.list(g)
print(glist)
rows <- rstack()
rows <- insert_top(rows, list(name = "bob", age = 24))
rows <- insert_top(rows, list(name = "joe", age = 27))
rows
print(rows)
rowsdf <- as.data.frame(rows)
print(rowsdf)
#' Remember the fibonacci sequence function from Exercise_one.R
fib <- function(n, call_count = TRUE){
if (call_count){
CALL_COUNTER <<- CALL_COUNTER + 1
}
if (n == 1 || n == 2){
return(1)
} else {
a <- fib(n - 1)
b <- fib(n - 2)
c <- a + b
return(c)
}
#' Now we are going to produce a table from before with stacks.
library(rstackdeque)
info <- rstack()
for (i in seq(1, 15)){
CALL_COUNTER <- 0
row  <- list(n = i, fibn = fib(i), calls = CALL_COUNTER)
info <- insert_top(info, row)
}
info
as.data.frame(info)
library(ggplot2)
infodf <- as.data.frame(info)
p <- ggplot(infodf) + geom_line(aes(x = n, y = fibn)) +
geom_line(aes(x = n, y = calls))
plot(p)
infodf <- as.data.frame(infodf)
p <- ggplot(infodf) + geom_line(aes(x = n, y = fibn)) +
geom_line(aes(x = n, y = calls))
plot(p)
infodf
ggplot(infodf) + geom_line(aes(x = n, y = fibn)) +
geom_line(aes(x = n, y = calls))
str(infodf)
?stackdeque
?rstackdeque
#'
print(head(as.data.frame(s)))
info <- rstack()
for (i in seq(1, 15)){
CALL_COUNTER <- 0
row  <- data.frame(list(n = i, fibn = fib(i), calls = CALL_COUNTER))
info <- insert_top(info, row)
}
library(ggplot2)
infodf <- as.data.frame(infodf)
p <- ggplot(infodf) +
geom_line(aes(x = n, y = fibn)) +
geom_line(aes(x = n, y = calls))
try(plot(p))
infodf
str(infodf)
info <- rstack()
for (i in seq(1, 15)){
CALL_COUNTER <- 0
row  <- as.data.frame(list(n = i, fibn = fib(i), calls = CALL_COUNTER))
info <- insert_top(info, row)
}
library(ggplot2)
infodf <- as.data.frame(infodf)
p <- ggplot(infodf) +
geom_line(aes(x = n, y = fibn)) +
geom_line(aes(x = n, y = calls))
try(plot(p))
rowsdf
str(rowsdf)
infodf
infodf <- as.data.frame(info)
str(info)
str(infodf)
infodf <- as.data.frame(info)
p <- ggplot(infodf) +
geom_line(aes(x = n, y = fibn)) +
geom_line(aes(x = n, y = calls))
try(plot(p))
info <- rstack()
for (i in seq(1, 15)){
CALL_COUNTER <- 0
row  <- list(n = i, fibn = fib(i), calls = CALL_COUNTER)
info <- insert_top(info, row)
}
library(ggplot2)
infodf <- as.data.frame(info)
p <- ggplot(infodf) +
geom_line(aes(x = n, y = fibn)) +
geom_line(aes(x = n, y = calls))
try(plot(p))
info <- rstack()
for (i in seq(1, 15)){
CALL_COUNTER <- 0
row  <- data.frame(list(n = i, fibn = fib(i), calls = CALL_COUNTER))
info <- insert_top(info, row)
}
library(ggplot2)
infodf <- as.data.frame(info)
p <- ggplot(infodf) +
geom_line(aes(x = n, y = fibn)) +
geom_line(aes(x = n, y = calls))
try(plot(p))
fib(4)
CALL_COUNTER <- 0
fib(4)
library(stringr)
fib <- function(n, call_count = TRUE){
CALL_COUNTER <<- CALL_COUNTER + 1
thiscall <- str_c("fib:n=", as.character(n))
CALL_STACK <<- insert_top(CALL_STACK, thiscall)
if (n == 1 || n == 2){
CALL_STACK <<- without_top(CALL_STACK)
return(1)
} else {
a <- fib(n - 1)
b <- fib(n - 2)
c <- a + b
CALL_STACK <<- without_top(CALL_STACK)
return(c)
}
CALL_STACK <<- rstack()
CALL_COUNTER <<- 0
print_string_stack <- function(s){
print(s)
}
print_string_stack <- function(s){
print(s)
}
fib <- function(n, call_count = TRUE){
CALL_COUNTER <<- CALL_COUNTER + 1
thiscall <- str_c("fib:n=", as.character(n))
CALL_STACK <<- insert_top(CALL_STACK, thiscall)
print_string_stack(CALL_STACK)
if (n == 1 || n == 2){
CALL_STACK <<- without_top(CALL_STACK)
print_string_stack(CALL_STACK)
return(1)
} else {
a <- fib(n - 1)
b <- fib(n - 2)
c <- a + b
CALL_STACK <<- without_top(CALL_STACK)
print_string_stack(CALL_STACK)
return(c)
}
CALL_STACK <<- rstack()
CALL_COUNTER <<- 0
info <- rstack()
for (i in seq(1, 15)){
CALL_COUNTER <- 0
row  <- data.frame(list(n = i, fibn = fib(i), calls = CALL_COUNTER))
info <- insert_top(info, row)
}
library(ggplot2)
infodf <- as.data.frame(info)
p <- ggplot(infodf) +
geom_line(aes(x = n, y = fibn)) +
geom_line(aes(x = n, y = calls))
try(plot(p))
CALL_STACK
fib(4)
print_string_stack <- function(s){
char_vec <- as.character(as.list(s))
print(char_vec)
}
fib <- function(n, call_count = TRUE){
CALL_COUNTER <<- CALL_COUNTER + 1
thiscall <- str_c("fib:n=", as.character(n))
CALL_STACK <<- insert_top(CALL_STACK, thiscall)
print_string_stack(CALL_STACK)
if (n == 1 || n == 2){
CALL_STACK <<- without_top(CALL_STACK)
print_string_stack(CALL_STACK)
return(1)
} else {
a <- fib(n - 1)
b <- fib(n - 2)
c <- a + b
CALL_STACK <<- without_top(CALL_STACK)
print_string_stack(CALL_STACK)
return(c)
}
CALL_STACK <<- rstack()
CALL_COUNTER <<- 0
info <- rstack()
fib(4)
print_string_stack <- function(s){
char_vec <- as.character(as.list(s))
print(rev(char_vec))
}
fib <- function(n, call_count = TRUE){
CALL_COUNTER <<- CALL_COUNTER + 1
thiscall <- str_c("fib:n=", as.character(n))
CALL_STACK <<- insert_top(CALL_STACK, thiscall)
print_string_stack(CALL_STACK)
if (n == 1 || n == 2){
CALL_STACK <<- without_top(CALL_STACK)
print_string_stack(CALL_STACK)
return(1)
} else {
a <- fib(n - 1)
b <- fib(n - 2)
c <- a + b
CALL_STACK <<- without_top(CALL_STACK)
print_string_stack(CALL_STACK)
return(c)
}
CALL_STACK <<- rstack()
CALL_COUNTER <<- 0
info <- rstack()
fib(4)
print_string_stack <- function(s){
char_vec <- as.character(as.list(s))
message(rev(char_vec))
}
fib <- function(n, call_count = TRUE){
CALL_COUNTER <<- CALL_COUNTER + 1
thiscall <- str_c("fib:n=", as.character(n))
CALL_STACK <<- insert_top(CALL_STACK, thiscall)
print_string_stack(CALL_STACK)
if (n == 1 || n == 2){
CALL_STACK <<- without_top(CALL_STACK)
print_string_stack(CALL_STACK)
return(1)
} else {
a <- fib(n - 1)
b <- fib(n - 2)
c <- a + b
CALL_STACK <<- without_top(CALL_STACK)
print_string_stack(CALL_STACK)
return(c)
}
CALL_STACK <<- rstack()
CALL_COUNTER <<- 0
info <- rstack()
fib(4)
print_string_stack <- function(s){
char_vec <- as.character(as.list(s))
message(rev(paste(char_vec, collapse = " ")))
}
fib <- function(n, call_count = TRUE){
CALL_COUNTER <<- CALL_COUNTER + 1
thiscall <- str_c("fib:n=", as.character(n))
CALL_STACK <<- insert_top(CALL_STACK, thiscall)
print_string_stack(CALL_STACK)
if (n == 1 || n == 2){
CALL_STACK <<- without_top(CALL_STACK)
print_string_stack(CALL_STACK)
return(1)
} else {
a <- fib(n - 1)
b <- fib(n - 2)
c <- a + b
CALL_STACK <<- without_top(CALL_STACK)
print_string_stack(CALL_STACK)
return(c)
}
CALL_STACK <<- rstack()
CALL_COUNTER <<- 0
info <- rstack()
fib(4)
fib(5)
fib(6)
fib(7)
fib(8)
kintr::spin
knitr::spin
?knitr::spin
library(knitr)
(s = system.file("examples", "knitr-spin.R", package = "knitr"))
spin(s)  # default markdown
o = spin(s, knit = FALSE)  # convert only; do not make a purse yet
knit2html(o)  # compile to HTML
#' Recursion and stacks
#' =====
#'
library(rstackdeque)
library(ggplot2)
library(reshape2)
#' ## How many licks does it take to get to a stack-overflow?
#'
#' 1. How big of a recursive stack will R handle?
#'
#' I'll tackle this problem by simply defining a neverending function that
#' appends a call to a global stack and then calls itself again.
useless_recursion <- function(n){
CALL_STACK <<- insert_top(CALL_STACK, n)
useless_recursion(n + 1)
}
CALL_STACK <<- rstack()
try(useless_recursion(0))
length(CALL_STACK)
#' Interestingly, when I tried a method utilizing the CALL_COUNTER global, it
#' turns out a little differently.
useless_recursion2 <- function(){
CALL_COUNTER <<- CALL_COUNTER + 1
CALL_STACK <<- insert_top(CALL_STACK, CALL_COUNTER)
useless_recursion2()
}
CALL_STACK <<- rstack()
CALL_COUNTER <<- 0
try(useless_recursion2())
length(CALL_STACK)
#' I seem to get the value 2464 in the knitr document, but 2489 when I run it manually.
#' Let's see what happens when I utilize the `sumupto()` function from Exercise_one.
tfun <- function(n){
CALL_COUNTER <<- CALL_COUNTER + 1
if (n == 1){
return(1)
} else {
tn <- n + tfun(n - 1)
return(tn)
}
CALL_COUNTER <<- 0
try(tfun(3000))
CALL_COUNTER
CALL_COUNTER <<- 0
try(tfun(824))
CALL_COUNTER
CALL_COUNTER <<- 0
try(tfun(823))
823*3
#' It seems that the stack for an R function is dependent on the function itself. I'm
#' not exactly sure why...
useless_recursion3 <- function(n){
if (n == 1){
CALL_STACK <<- insert_top(CALL_STACK, n)
return(n + useless_recursion3(n))
} else if (n == 0){
CALL_STACK <<- insert_top(CALL_STACK, "whee")
return(useless_recursion3(n))
} else {
CALL_STACK <<- insert_top(CALL_STACK,  n + n - 1)
return(n + useless_recursion3(n) - useless_recursion3(n - 1))
}
CALL_STACK <<- rstack()
try(useless_recursion3(9001))
length(CALL_STACK)
CALL_STACK <<- rstack()
try(useless_recursion3(1))
length(CALL_STACK)
CALL_STACK <<- rstack()
try(useless_recursion3(0))
length(CALL_STACK)
#'
#' It almost seems as if the call stack is affected by any operations done on local
#' variables.
#'
#' ## Problem 2: Nicholson-Bailey Model
#'
#' $$
#' H_{t} = \gamma \cdot H_{t-1} \cdot e^{-a \cdot P_{t-1}}\\
#' P_{t} = H_{t-1} \cdot \left(1 - e^{-a \cdot P_{t-1}}\right)
#' $$
#'
#' Write a function for these assuming that $t_1$ has 10 hosts and 2 parasites.
#' Instead of doing 10 hosts and 2 parasites, I'm drawing randomly from a
#' Poisson distribution with $\lambda = 2$ and $\lambda = 10$ for parasites and
#' hosts, respectively.
hosts <- function(t, gamma = 2, a = 0.1, seed = 9999){
if (t == 1){
set.seed(seed)
Ht1 <- rpois(1, 10)
return(Ht1)
} else {
Htm1 <- hosts(t - 1, gamma, a, seed)
Ptm1 <- parasites(t - 1, gamma, a, seed)
Ht   <- Htm1 * exp(-a * Ptm1)
return(Ht)
}
parasites <- function(t, gamma = 2, a = 0.1, seed = 9999){
if (t == 1){
set.seed(seed)
Pt1 <- rpois(1, 2)
return(Pt1)
} else {
Htm1 <- hosts(t - 1, gamma, a, seed)
Ptm1 <- parasites(t - 1, gamma, a, seed)
return(Htm1 * (1 - exp(-a * Ptm1)))
}
#'
#' Now to run the simulations 10 times to see what happens.
#+ cache = TRUE
HP_STACK <<- rstack()
set.seed(9999)
seeds <- sample(10000, 10)
seed <- seeds[1]
for (i in 1:20){
df <- data.frame(list(host     = hosts(i, seed = seed),
parasite = parasites(i, seed = seed),
t        = i,
seed     = seed
)
HP_STACK <- insert_top(HP_STACK, df)
}
hpdf <- as.data.frame(HP_STACK)
ggplot(melt(hpdf, measure.vars = c("host", "parasite")),
aes(x = t, y = value, color = variable)) +
geom_line(aes(linetype = factor(seed)), alpha = 0.5) + geom_smooth()
seeds <- sample(10000, 10)
for (r in 1:2){
seed <- seeds[r]
for (i in 1:20){
df <- data.frame(list(host     = hosts(i, seed = seed),
parasite = parasites(i, seed = seed),
t        = i,
seed     = seed
)
HP_STACK <- insert_top(HP_STACK, df)
}
hpdf <- as.data.frame(HP_STACK)
#' Now to plot
ggplot(melt(hpdf, measure.vars = c("host", "parasite")),
aes(x = t, y = value, color = variable)) +
geom_line(aes(linetype = factor(seed)), alpha = 0.5) + geom_smooth()
seeds <- sample(10000, 10)
for (r in 1:2){
seed <- seeds[r]
for (i in 1:20){
df <- data.frame(list(host     = hosts(i, seed = seed),
parasite = parasites(i, seed = seed),
t        = i,
seed     = seed
)
HP_STACK <- insert_top(HP_STACK, df)
}
hpdf <- as.data.frame(HP_STACK)
#' Now to plot
ggplot(melt(hpdf, measure.vars = c("host", "parasite")),
aes(x = t, y = value, color = variable)) +
geom_line(aes(linetype = factor(seed)), alpha = 0.5) + geom_smooth()
ggplot(melt(hpdf, measure.vars = c("host", "parasite")),
aes(x = t, y = value, color = variable)) +
geom_line(aes(linetype = factor(seed)), alpha = 0.5)
ggplot(melt(hpdf, measure.vars = c("host", "parasite")),
aes(x = t, y = value, color = variable)) +
geom_line(aes(linetype = factor(seed)), alpha = 0.5, size = 2)
ggplot(melt(hpdf, measure.vars = c("host", "parasite")),
aes(x = t, y = value, color = variable)) +
geom_line(aes(linetype = factor(seed)), alpha = 0.5, size = 1.5)
ggplot(melt(hpdf, measure.vars = c("host", "parasite")),
aes(x = t, y = value, color = variable)) +
geom_line(aes(linetype = factor(seed)), alpha = 0.5)
ggplot(melt(hpdf, measure.vars = c("host", "parasite")),
aes(x = t, y = value, color = variable)) +
geom_line(aes(linetype = factor(seed)), alpha = 0.5) + theme_minimal()
ggplot(melt(hpdf, measure.vars = c("host", "parasite")),
aes(x = t, y = value, color = variable)) +
geom_line(aes(linetype = factor(seed)), alpha = 0.5) + theme_classic()
